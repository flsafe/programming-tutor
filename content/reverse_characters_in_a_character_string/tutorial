<h1>Getting Started</h1>
<p>
This problem is one you may expect to get as a warm up
or to weed out those who really don't know how to
program. Since there isn't too much to this problem, let's just
get started.
</p>

<p>
The general strategy is to swap the first character with the last
character. Then swap the second character with the second to 
last character and so on.
</p>

<p>
We will use two indexes named <i>first</i> and <i>last</i> that initially
index the first and last element of the input array.
</p>

<p>
The algorithm will write the character at <i>str[first]</i> to a <i>temp</i>
variable. Then it will write the character at <i>str[last]</i> to <i>str[first]</i>
and the character at <i>temp</i> to <i>str[last]</i>.
</p>

<p>
To swap the next characters in the array we increment first and decrement last.
But how do we know when to stop? After each iteration of this algorithm
first and last get closer and closer. The whole time <i>first</i> &lt; <i>last</i>
until they cross in the middle of the input array. 
</p>

<p>
After they cross in the middle first &gt; last. When this happens we know
to stop.
</p>

<h1>Edge Cases?</h1>
<p>
Do we need to be careful depending on whether the input string is
even or odd? Not really the algorithm works for both cases! If the
input string is even then <i>first</i> and <i>last</i> will swap the
middle two elements.
</p>

<p>
If the input string is odd then, then <i>first</i> and <i>last</i> will
swap the one middle element with itself.
</p>

<h1>Efficiency</h1>
<p>
Say the input array length is <i>n</i>. Unfortunately in C simply 
determining the size of the input array with the function <i>strlen</i>
is already <i>n</i> steps. 
</p>

<p>
Let's consider each swap just one step. The algorithm swap the first
element with the last, the second with the second to last and so on. If the
input array was even then the number of step is just the length of the input
array divided by 2. 
</p>

<p>
If input array length is odd then, the number of steps is the ceiling of
the array length divided by 2. This is because the middle element has to be swapped 
with itself. 
</p>

<p>
Then our algorithm is just O(n + ceiling(n/2)), or just O(n).
</p>
