<h1 id="getting-started">Getting Started</h1>
<p>
Removing characters from an array sounds pretty easy, like staining your
nice shirt on a posh night out. Despite the easy sounding description
there are some interesting choices and trade offs to be made. Let's get started.
</p>

<h1 id="our-first-solution">Our First Solution</h1>
<p>
Let's begin with a pseudo code outline of one possible solution.
</p>

[startcode]
for each character C in STR
  if C is a character we want to delete 
    remove C from STR
[endcode]

<p>
Reviewing the pseudo code leads to our first question. How are
we going to remove characters from the array? Imagine
a line of attractive people waiting in front of a cashier. 
When a person in the middle of the line leaves, those still waiting
shift forward to fill in the space left by the impatient quitter. Deleting
an element from an array is the same concept. The attractive people are irrelevant.
For example figure 1 shows what the shift would look like.
</p>

<img src="http://images.blueberrytree.ws/shifting_array.png"/>
<div class="description">
Figure 1. We are deleting the character <i>c</i> by shifting the other characters.
</div>

<p>
The code below is one way of solving this problem and, to the uninitiated,
is the obvious way to solve it.
</p>

[startcode]
 [[solution2.c]]
[endcode]

<h1 id="obvious-and-ineffcient">An Obvious and Inefficient Solution</h1>
<p>
The solution above certainly works and it is easy enough to derive and
grok. Unfortunately it is inefficient. I can hear your interviewer now...
"Can you do better?". 
</p>

<p>
Well, that depends, is Fe a metal in the first transitional series?
</p>

<h1 id="do-better">How Can We Do Better?</h1>
<p>
To help us make this algorithm more efficient let's examine why it is inefficient.
Imagine the case where all the characters of the input string 
must be deleted. 
</p>

<p>
To delete the first character the algorithm has to locate it in <i>remove_chars</i>. This takes at most
<i>m</i> steps, where <i>m</i> is the size of <i>remove_chars</i>. Next the algorithm
shifts the <i>n</i> characters located to the right of the first character. Remember
that this includes the null character. 
</p>

<p>
Then, to delete the second character, the algorithm searches for it in
<i>remove_chars</i> (<i>m</i> steps) and shifts the remaining <i>n</i> - 1 characters. Which works
out to an additional <i>m</i> + (<i>n</i> - 1) steps.
</p>

<p>
Starting to see a pattern?
</p>

<h1 id="math-content">Warning! Math Content</h1>
<p>
 When the algorithm deletes the first character of
<i>str</i> it performs <code>m + n</code> steps. To delete the second character it performs
<code>m + n - 1</code> steps. Deleting the third character is another <code>m + n - 2</code> steps.
We can add up all the steps with the closed form of the <a href="http://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%C2%B7_%C2%B7_%C2%B7">series</a> below.
Ultimately this algorithm is O(n^2 + (n * m)). Some of you may have noticed I left out
the call to <i>strlen</i> in my calculation. I make no apologies as it is an exercise
for the reader :)
</p>

<pre><code>
  (m + n) + (m + n - 1) + (m + n - 2) + .. + (m + 1)

= (1 + 2 + 3 + .. + n) + (n * m)

= (n (n + 1)) / 2  +  (n * m)

= ((n^2 / 2) + (n / 2) + (n * m)

  O( (n^2 / 2) + (n / 2) + (n * m) )

  I thusly pronounce this algorithm O(n^2 + (n * m))
</code></pre>

<p>
Right away we see that our algorithm is dominated by all the shifting and searching. Yuck.
Any ideas on how to improve this ? What efficient data structures are available for searching?
</p>

<p>
Just for fun I've learned to use GNUPlot and plotted some run times for this algorithm on
my laptop. The <i>remove_array</i> was "1234567890abcdefghijklmnopqrstuvwxyz" and 
I made sure that every element of the input <i>str</i> would be deleted. Notice that
in figure 2 the run time growth of the algorithm isn't linear. Muahahahah! Just as we
predicted. Math <em>is power.</em>
</p>

<img src="http://images.blueberrytree.ws/remove-chars-naive.png" />
<div class="description">
Figure 2. The run times of our naive algorithm for different sized inputs
</div>

<h1 id="better-impelementation">A Better Implementation</h1>
<p>
Before we delete a character it must be found in the <i>remove_chars</i> array.
The algorithm above uses a <i>for</i> loop to find characters in <i>remove_chars</i>. 
</p>

<p>
Let's figure out a better way to test if a character
from the input string is included in the <i>remove_chars</i> array. 
What other data structures could we use for searching? 
Which should we choose? Why?
</p>

<p>
To make an appropriate decision we must consider the input data to our algorithm.
For simplicity let's only deal with 1 byte unsigned ASCII characters (all 128 of them). Because of the limited
interview time this assumption is pretty common. 
</p>

<p>
Since we are dealing with ASSCII characters we know that we will only be searching 
at most 128 characters. If we use an array based hash table to store these
characters we will only use 128 bytes in memory.
</p>

<p>
If we use a binary tree, each node of the tree stores the character (1 byte) plus a left pointer (Assume 4 bytes)
and a right pointer (4 bytes). Each node then uses at least 9 bytes for a
total of 1152 bytes! Since our characters are so small
and there are only 128 of them, we should use an array based hash table.
</p>

<p>
But we aren't going to implement a full blown hash table with a sophisticated
hash function and chaining. We can use an array
as a simple hash table. Take a look at the array definition below. Any ideas
on how we can use <i>remove</i> like a hash table?
</p>

[startcode]
char removetab[128] = {0};
[endcode]


<h1 id="three-hints">Three Hints</h1>

<p>
In C, what is the relationship between a character and an integer?
A character type in C has an integer value. At least 8 bits, but could
be more on your machine. Could the integer value be negative? Yup, again depends on the
platform. That's why we are assuming unsigned 8-bit ASSCII characters but be aware of potential differences
between character encodings.
</p>

<p>
Here are three pieces of information, can you see where we are going with this?
</p>

<ol>

<li>
We index
arrays with positive integers values.
</li> 

<li>
Characters have positive integer values (In ASCII).
</li>

<li>
Accessing an array is always constant time. For example accessing removetab[0] takes
the same time as removetab[127].
</li>

</ol>

<h1 id="the-answer">The Answer</h1>
<p>
Suppose we want to remove the character <i>c</i> from our input string.
Then we set removetab[<i>c</i>] to 1.
</p>

[startcode]
removetab[c] = 1;
[endcode]

<p>
When it comes time to check if a some character in our input string <i>str</i>
should be removed we check to 
see if <i>removetab[ somecharacter ]</i> is set to 1 (true).
For example:
</p>

[startcode]
  /* code */

  for(i = 0 ; str[i] ; i++)
    if( removetab[ str[i] ] )
      /*remove the character at str[i]*/
    else
      /*Do something else*/
  }
[endcode]

<p>
No need to traverse the entire length of the <i>remove_chars</i> array to determine
if a character should be deleted. Now we can determine in constant time if a character in the input string
needs to be deleted. 
</p>

<p>
Or we can determine if a character is a duplicate, or
unique, or count the instances of the character and wash the dishes. Keep
this technique in mind, it comes in handy.
</p>

[startcode]
int count[128] = {0};       /*We have assumed ASCII*/
for(i = 0 ; str[i]  ; i++){
  count[ str[i] ]++;
  if( count[ str[i] ] > 1 ){
    /* str[i] is a duplicate */
  }
}
[endcode]

<h1 id="shifting">What About All That Shifting?</h1>
<p>
So far we haven't really tackled the most inefficient aspect of the algorithm.
Suppose that we allocate a new temporary buffer the same size as the input string.
We can copy all the characters of our input string into the temporary buffer but skip
the characters we want to delete.
</p>

[startcode]
BUF is the same size as STR

for each character C in STR
  if C is not going to be removed 
    copy C to BUF

return BUF
[endcode]

<p>
In figure 3 below we are deleting the character c. The characters a,b,d,e,f and \0 all get copied
over into the new buffer. But not c because nobody likes that stinking consonant.  
</p>

<img src="http://images.blueberrytree.ws/remove-char-with-output-buffer.png"/>
<div class="description">Figure 3. Removing a character from the input string (top) by leaving it out of the
temporary buffer (bottom).</div>

<p>
We've now deleted characters without shifting but the trade off is increased memory usage. What if our input string was several giga bytes?
We would need a second buffer thus doubling our memory usage. Can we do better?
</p>

<h1 id="another-hint">Another Hint</h1>
<p>
Can you figure out a way to do the same thing without allocating another buffer?
How could you do this using only the input array string?
</p>

<h1 id="how-to-doit">How To Do It</h1>
<p>
First let's consider how to implement the concept above using an extra buffer. I've written
a solution using an extra buffer.
</p>

[startcode]
[[solution3.c]]
[endcode]

<p>
Yikes! That's came out to be longer than I expected. 
</p>

<p>
The algorithm maintains two indices <i>read</i> and <i>write</i>. The index <i>read</i> indexes into
the input string. The index <i>write</i> indexes into the temporary buffer. Both have the initial value
of 0.
</p>

<p>
Each character at <i>str[read]</i> is written to <i>tmp_buffer[write]</i> only when 
the character is not going to be deleted. The <i>read</i> index is incremented after every read and
the <i>write</i> index is incremented after every write.
</p>

<p>
In figure 4 below the character <i>c</i> has been deleted by writing
<i>d</i> in its place.
</p>

<img src="http://images.blueberrytree.ws/read-write-heads.png"/>
<div class="description">
Figure 4. After the
algorithm reads a character <i>read</i> is incremented. After a character is written to 
<i>tmp_buffer</i> <i>write</i> is incremented.
</div>

<p>
Let's try and do the same thing without using the 
temporary buffer. If <i>read</i> and <i>write</i> both indexed into the input string and not
two separate ones would this algorithm still work? Try it out.
</p>

<h1 id="effcient-elegant">An Efficient And Elegant Way Of Doing This</h1>
<p>
We don't have to allocate a temporary buffer. Notice in figure 4 above that the algorithm 
never writes a character before <i>read</i> gets a chance to read it. In other words if 
<i>read</i> and <i>write</i> both indexed into the same array, as far as <i>read</i> is concerned
the input string never gets modified.
So there is no trouble using both <i>read</i> and <i>write</i> within the same array.
</p>

<p>
Here is a solution that takes advantage of this.
</p>
[startcode]
[[solution.c]]
[endcode]

<p>
This is by far the shortest and the most efficient solution we've seen.
What about its worst case run time behavior? For each character in the input string the
algorithm reads a character from the input string and then writes
a character to the "temporary buffer". Let's consider that one step. So if the input string is length <i>n</i>
then, at most the algorithm does <i>n</i> steps.
</p>

<p>
The algorithm also allocates space for <i>removetab</i> in the source code.
Setting what characters get deleted in <i>removetab</i> requires at most <i>m</i> steps, where
<i>m</i> is the number of characters we need to remove.
<p>

<p>
Therefore our algorithm is O(<i>m</i> + <i>n</i>). Which means it is linear! 
</p>

<h1 id="what-we-learned">What We Learned</h1>
<ol>
<li>
ASCII characters map to an integer, it is possible to use this integer value to
index into an array.
</li>

<li>
An efficient way of removing characters from an array is to "pretend" to write
them to a temporary buffer, minus the characters we want to delete.
</li>
</ol>

<h1 id="exercises">Exercises</h1>
<p>
We've allocated a character array to keep track of what characters
need to be deleted. What other data structures could be used? Try using a
bit vector or a binary search tree then benchmark and compare.
</p>
