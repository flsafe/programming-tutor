<h1 id="introduction">Introduction</h1>

<p>
This exercise examines your knowledge of stacks, linked lists and pointers.
I've included a bit on pointers and structs in
this tutorial but my focus is on implementing
the stack and not the basics of structs and pointers. Check out my list
of tutorials <a href="http://www.blueberrytree.ws/tutorials">here</a> to brush up
on your skills.
</p>

<h1 id="stacks">Stacks</h1>
<p>
Stacks are an interesting data structure. Their behavior can model the concept of
"leaving <i>something</i> to do another thing" and then "returning to the original <i>something</i>".
For example calling a function in a computer program. The function that is called executes
its instructions to completion, then the control returns to the caller. 
This behavior is also useful for traversing trees in 
<a href="http://en.wikipedia.org/wiki/Depth_first_search">Depth-first search</a> order.
</p>

<p>
If you guessed that a stack is analogous to a stack of stuff, like beer containers, then you
are right. They are both lots of fun. 
</p>

<p>
Stacks are typically defined with three operations: <i>pop</i>, <i>push</i> and <i>peek</i>.
<p>

<p>
Imagine a stack of something, say beer containers, and the stack data structure is
easy enough to understand. Place (push) a stout on the table. Place (push) a lambic on
top of that. Then place (push) a lager on top of that. Now the lager is at
the top of the stack. 
</p>

<p>
Remove the lager (pop) and the lambic is at the top. Next
remove the lambic (pop) and the stout is at the top. Pop one more time
and the stack is empty. Take a look at figure 1 one to see
what this would look like. In the U.S this could be a neat bar trick.
</p>

<img src="http://images.blueberrytree.ws/push-pop-beer-containers.png"
     alt="Pushing an poping onto the stack"/>
<div class="description">
Figure 1. Pushing onto the stack places
a new thing on top. Popping removes the thing from the top
of the stack</div>

<p>
The peek operation returns the item at the top of the stack 
but doesn't remove it. In the example above,
when the lager was at the top of the stack, the peek operation
would have returned the lager but not remove it form the stack.
</p>

<p>
The order of removal is then lager, lambic, stout. Notice that
the order is first in, last out (FILO) or last in first out (LIFO). Pop removes and returns
items in the reverse order that they were placed into the stack.
</p>

<h1>Alright, Stacks Are Easy. What About Linked Lists?</h1>
<p>
The problem asks us to implement the stack using a linked list.
A linked list is a structure made up of "nodes". Each node
contains both data and a reference, in our case a pointer, to the
next node. Thus we have a list of nodes that are all linked to each other.
</p>

<p>
There is a special pointer called the head pointer. It points to the
first node of the linked list. This is important because without it
there would be no way to access the linked list in memory. Kind of like
loosing the remote control to the television. As we manipulate the
linked list it is important to maintain the head pointer correctly. 
I have used my amazingly adequate drawing skills to show you
what this looks like in figure 2 below.
</p>

<img src="http://images.blueberrytree.ws/linked-list.png"
     alt="Nodes linked to eachother via via pointers. A special
          head pointer points the first node of the list"/>
<div class="description">
Figure 2. The special head pointer points to the first node. Each
node of the has a pointer to the next node in the list. The last
node points to null.
</div>

<p>
Our <i>push</i> operation is implemented by 
inserting a new node as the first node of the linked list.
The pop operation is implemented by removing the first node.
Now we can imagine that the "top" of our stack is always the first
element of this linked list.
</p>

<p>
Adding the first node of a linked list involves 
allocating a new node, linking it to the first node, then
updating the head pointer to point to the newly allocated node as seen in
figure 3 below.
</p>

<img src="http://images.blueberrytree.ws/insert-front-linked-list.png"
     alt="Inserting a new node at the front of the linked list"/>
<div class="description">
Figure 3. Each node has data and a "next" pointer that points to the next
node in the list. The newly allocated node's "next" pointer points to the first
node. Then head gets updated to point to the new node.
</div>

<p>
To remove the first node we update head to
point to the second node of the linked list. Then we
deallocate the node node previously pointed to by head.
Figure 4 shows how to do it.
</p>
<img src="http://images.blueberrytree.ws/remove-front-linked-list.png.png"
     alt="Removing the first node of a linked list requires updating 
          head to point to the second node in the list. Be careful
          not to loose your original pointer to the first node when updating
          head!"/>
<div class="description">
Figure 4. Removing the first node of a linked list requires updating 
head to point to the second node in the list. Be careful
not to loose your pointer to the first node when updating
head! We still need it to free the node memory. Here I've temporally stored it
in tmp. 
</div>

<p>
Not too bad! However, the devil is in the details! Especially
since we are solving this exercise in C. The pointer manipulation
can be difficult to understand. 
</p>

<p>
Let's take a look at a solution that puts all this together. However,
it's not quite right.
</p>

[startcode]
typedef struct stack stack;
struct stack{   /* This is our node definition */ 
  stack *next;  /* A pointer to the next node  */
  int  val;     /* Our data is just an integer */
};

int push(stack *s, int val){
  stack* newnode = malloc(sizeof(stack));
  if(! newnode)
    return 0;

  newnode->val = val;
  newnode->next = s;

  s = newnode;

  return 1;
}

int pop(stack *s, int *val){
  stack* top;
  if(! s)
    return 0;

  top = s;
  *val = top->val;
  s = top->next;
  free(top);

  return 1;
}
[endcode]

<p>
The function <i>push</i> takes two arguments. The first, <i>s</i>, is
the head pointer to our linked list based stack. The second, <i>val</i>,
is the integer value to insert into the stack.
</p>

<p>
The function allocates memory, with <i>malloc</i>, for the new node then assigns its 
<i>val</i> and <i>next</i> values. If the memory allocation <i>malloc</i> fails then 
0 is returned to indicate that the insertion failed. Then the head pointer, <i>s</i>, is
updated to point to the new node. 
</p>

<p>
Pop also takes two arguments. The first, <i>s</i>, is the head pointer.
The second is a pointer to an integer where the poped data value can be stored.
First the function tests if <i>s</i> is NULL. This happens
when the stack is empty. If this is the case then it returns 0 to indicate
that the <i>pop</i> operation failed. After all we can't <i>pop</i> anything if there
is nothing to pop. Next it temporarily stores the head pointer <i>s</i> in <i>top</i>,
updates the head pointer to point to the second node, then frees the
memory pointed to by <i>top</i>.
</p>

<p>
So what's wrong with the code above? Lets take a look at
a snippet of code that uses the implemention above. 
</p>

[startcode]
stack* head = NULL;  /* An empty stack */

push(head, 1); /* ? head->val = 1 */

push(head, 2); /* ? head->val = 2 */

push(head, 3); /* ? head->val = 3 */
[endcode]

<p>
We start with a head that points to NULL, also
known as an empty linked list. Then we
push several elements into our stack. As described in the previous figures, 
when we push into the stack the expectation is that the head pointer
will be updated and point to the new node. But that doesn't happen.
</p>

<p>
Remember that <i>head</i> is passed as a function argument by value.
When <i>push</i> or <i>pop</i> are called, they are given not some kind
of reference to <i>head</i> but a copy of head. Because head is a pointer,
a memory address, the function receives a copy of a memory address. 
</p>

<p>
Inside push and pop, you can mess with the copy of head all you want but it will never
affect the client code's head. This is where the bug is. Head
is never updated.
</p>

<h1 id="pointer_to_a_pointer" class="description">
A Pointer To A Pointer To A Node
</h1>

<p>
You may have seen code that uses the following idiom:
</p>

[startcode]
struct system_settings settings;

get_default_settings(&settings); 
settings.setting1 == 10; /* true */
settings.pwn      == 1;  /* true */

void get_default_settings(struct system_settings *settings){
  settings->setting1 = 10;
  settings->pwn      = 1;
}
[endcode]

<p>
Our imaginary system settings struct can be modified by the function 
<i>get_default_settings</i> because we pass a pointer to the 
struct and not a copy of it. The function
uses its pointer parameter to update the structure
using the <i>-&gt;</i> operator.
We can fix our stack implementation by applying the same concept only
instead of using a pointer to a struct, we will use a pointer
to a pointer. 
</p>

[startcode]
stack *head = NULL;

push(&head, 1); /* Notice I'm now using &head */ 

push(&head, 2);

push(&head, 3);
[endcode]

<p>
Notice that the function argument is 
<i>&amp;head</i>. Now that our <i>push</i> and <i>pop</i> functions have a pointer
to the head they can update it. This is what we needed all along!
Let's see an updated implementaion:
</p>

[startcode]
[[solution.c]]
[endcode]

<p>
The functions push and pop take a pointer to head as an argument. To access head 
within push and pop we use the <i>*s</i> notation. Remember that the dereference 
operator <i>*</i> is used to reference what the pointer points to. 
Say this three times fast: s is a pointer to the head pointer, *s
is the head pointer; a pointer to the head node. 
</p>

<p>
Some code snippets to illustrate my point:
</p>

[startcode]
stack *head = *s;         /* head is the pointer to the first element */

/* or */

stack *top_of_stack = *s; /* top_of_stack is a pointer to the first element */

/* or */

stack *first_node = *s;   /* first_node is a pointer to the first element */
[endcode]

<p>
To access the struct values of the head node we could use the following code.
</p>

[startcode]
int val = (*s)->val;
stack *second_node = (*s)->next;
[endcode]

<p>
This notation is a bit funky. The parenthesis around the <i>*s</i>
are required because the <i>-&gt;</i> precedence is higher than the
<i>*</i> operator. 
</p>

<h1 id="array-stack">An Alternative Implementation</h1>

<p>
Of course there are other ways to implement a stack. We could also use an array, albeit
the implementation is more involved because a stack array has to dynamically expand as we push more
items and dynamically shrink was we pop items off.
This could make stack operations very slow if our array were to have
serveral million items. We could get around this by implementing a fixed size stack, say size 100, but
what if that is not enough? Or it's too much?
</p>

<p>
Despite these disadvantages an array based stack can be faster than a linked list
based stack. In a linked list stack, every time we push an item into the stack
we allocate new memory with <i>malloc</i>. An array based implementation
doesn't have this overhead. Additionally, if the data size in each node is small then the overhead
of <i>malloc</i> may not be worth it. As is the case in the implementation above. 
</p>

<h1 id="exercises">Exercises</h1>
<ol>
  <li>
      Given that our stack holds integers, 
      is our linked list based implementation appropriate? 
      If not, what should we change? What if we wanted to somehow 
      push very large structs into our stack?
  </li>

  <li>
    Implement a fixed sized, array stack. Bonus cool points
    if you make it resize when full or under capacity.
  </li>
</ol>
