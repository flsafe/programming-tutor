#!/usr/bin/ruby

require 'rubygems'
require 'yaml'
require 'active_record'
require 'active_support'
require 'logger'
require 'easy_roles'
require 'authlogic'
require 'pp'

# Assumes this script is called from the project root
PROJ_HOME = Dir.getwd
CONTENT_HOME = "#{PROJ_HOME}/content"

# The c header file for the template utils
COZY_TEMPL_UTIL_H = "#{PROJ_HOME}/content/cozy_template_utils.h"

# The cozy template utils that control system resources when running the user soluton
COZY_TEMPL_UTIL_C = "#{PROJ_HOME}/content/cozy_template_utils.c"

# In the exercse text use <filename.c> to subsititue file text
FILE_SUB_REGEX = /\[\[(.+)\]\]/

# Text between [startcode] and [endcode] is wrapped around <pre><code> </code></pre>
# and any < characters in between are escaped to &lt;
CODE_TAG_REGEX = /\[startcode\](.*?)\[endcode\]/m

# Establish DB connection here because some gems require
# a DB before being loaded
#ActiveRecord::Base.logger = Logger.new(STDERR)
db_config = YAML::load(File.open("#{PROJ_HOME}/config/database.yml"))
ActiveRecord::Base.establish_connection(db_config[ ENV['RAILS_ENV']||'development'] )

require 'acts-as-taggable-on'

# Load the exercise model files
require "#{PROJ_HOME}/lib/cozy_string_utils"
require "#{PROJ_HOME}/lib/unit_test_runner"
require "#{PROJ_HOME}/app/models/user"
require "#{PROJ_HOME}/app/models/exercise_set"
require "#{PROJ_HOME}/app/models/hint"
require "#{PROJ_HOME}/app/models/unit_test"
require "#{PROJ_HOME}/app/models/solution_template"
require "#{PROJ_HOME}/app/models/grade_sheet"
require "#{PROJ_HOME}/app/models/exercise"

Dir.chdir(CONTENT_HOME)

def start
  Dir.foreach(Dir.getwd) do |exercise_title|
    create_or_update_by(exercise_title) if valid_exercise?(exercise_title)
  end
  delete_unused_content
end

def delete_unused_content
  ex_db = ExerciseInfo.new.load("#{CONTENT_HOME}/exercise-sets.yml")
  
  # push_id isn't defined in this environment, load
  # it from the db
  ExerciseSet.define_attribute_methods
  Exercise.define_attribute_methods

  @sets = ExerciseSet.find :all
  @sets.each do |s|
    unless ex_db.set_exists?(s.push_id)
      puts " Destroying set: #{s.title}"
      s.destroy
    end
  end

  Exercise.find(:all).each do |e|
    unless ex_db.exercise_exists?(e.push_id)
      puts " Destroying exercise: #{e.title}"
      e.destroy
    end
  end
end

def valid_exercise?(exercise_title)
  if File.directory?(exercise_title)
    exercise_title != "." and exercise_title != ".."
  end
end

def create_or_update_by(exercise_title_dir)
  pcwd = Dir.getwd
  Dir.chdir(exercise_title_dir)

  ex_db = ExerciseInfo.new.load("#{CONTENT_HOME}/exercise-sets.yml")
  exercise_title = exercise_title_dir.titleize
  exercise_push_id = ex_db.exercise_info(exercise_title)[:push_id]
  begin
    exercise = Exercise.find_by_push_id(exercise_push_id) || Exercise.new
    if not exercise.new_record? and exercise.title != exercise_title
      puts " Renaming exercise: #{exercise.title} => #{exercise_title}"
    end
    exercise.title = exercise_title
    populate_and_save_exercise(exercise)
  rescue Exception
    puts "Oops! #{$!}" 
    puts $!.backtrace
    exit 1
  end

  Dir.chdir(pcwd)
end

def populate_and_save_exercise(exercise)
  populate_primitives(exercise)
  populate_assoc_models(exercise)
  save_with_exercise_set_and_order(exercise)
end

def populate_primitives(exercise)
    #TODO: Use look at the database fields to figure out
    # what fields to read in.
    exercise.description = read_field('description')
    exercise.problem = read_field('problem')
    exercise.tutorial =  read_field('tutorial')
    exercise.minutes = read_field('minutes').to_i
    exercise.finished = read_field('finished').to_i
    exercise.algorithm_list = read_field('algorithm_list')
    exercise.data_structure_list = read_field('data_structure_list')
end

def populate_assoc_models(exercise)
  # TODO: Currently only supporting one solution template and unit test
  # per exercise. 
  exercise.solution_templates.replace( new_solution_template )
  exercise.unit_tests.replace( new_unit_test )
  exercise.hints.replace( new_hints )
end

def new_solution_template
  template = SolutionTemplate.new
  template.src_language = 'c'
  template.src_code = IO.read('solution_template.c')
  [ template ]
end

def new_unit_test
  unit_test = UnitTest.new
  unit_test.src_language = 'ruby'
  unit_test.src_code = IO.read('unit_test.rb')
  [ unit_test ]
end

def new_hints
  hints = []
  Dir.foreach(Dir.getwd) do | filename | 
    if hint_file?(filename)
     hint = Hint.new
     hint.text = IO.read(filename)
     hints << hint
    end
  end
  hints
end

def save_with_exercise_set_and_order(exercise)
   exercise_db = ExerciseInfo.new()
   exercise_db.load("#{CONTENT_HOME}/exercise-sets.yml")
   exercise_info =  exercise_db.exercise_info(exercise.title)
   exercise_info or raise "No exercise info found: #{exercise.title}"

   set = ExerciseSet.find_by_push_id(exercise_info[:exercise_set_push_id]) || ExerciseSet.new
   if not set.new_record? and set.title != exercise_info[:exercise_set_title]
     puts " Ranaming set: #{set.title} => #{exercise_info[:exercise_set_title]}"
   end
   set.title = exercise_info[:exercise_set_title] 
   set.description = exercise_info[:exercise_set_description] 
   set.push_id = push_id() if set.new_record?
   exercise_db.set_exercise_set_info(set.title, :push_id=>set.push_id)
   set.save!

   exercise.order = exercise_info[:order]
   exercise.push_id = push_id() if exercise.new_record?
   exercise_db.set_exercise_info(exercise.title, :push_id=>exercise.push_id)
   puts "#{' (New) ' if exercise.new_record?}Saving: #{exercise.title}"
   set.exercises << exercise or raise "Couldn't save #{exercise.title}\n#{exercise.errors.full_messages()}"

   exercise_db.save()
end

def hint_file?(filename)
  filename =~ /^hint\d+/
end

def read_field(field)
  perform_subs( IO.read(field).strip.chomp )
end

def perform_subs(text)
  complete_text = sub_file_references(text)
  escaped_text = sub_start_end_code(complete_text)
end

def sub_file_references(text)
  while FILE_SUB_REGEX =~ text
    text = sub_file_reference(text) 
  end
  text
end

def sub_file_reference(text)
  filename = FILE_SUB_REGEX.match(text)[1]
  if filename 
    filetext = CozyStringUtils.escape_back_slashes(IO.read(filename))
    text.sub(FILE_SUB_REGEX, filetext).strip
  else
    text
  end
end

def sub_start_end_code(text)
   text.gsub(CODE_TAG_REGEX) do |match|
      match.gsub!(/(\[startcode\]|\[endcode\])/, '')
      "<pre><code>" + match.gsub(/</, '&lt;').strip + "</code></pre>"
  end
end

def push_id()
  id = IO.read("#{CONTENT_HOME}/push_ids").to_i
  next_id = id + 1
  File.open("#{CONTENT_HOME}/push_ids", 'w') do |f|
    f.write(next_id.to_s)
  end
  id
end

class ExerciseInfo

  def set_exists?(push_id)
    @exercise_sets.detect {|s| s[:push_id].to_i == push_id.to_i} != nil
  end

  def exercise_exists?(push_id)
    @exercise_sets.detect do |s|
      s[:exercises].detect {|e| e[:push_id].to_i == push_id.to_i} != nil
    end
  end

  def load(file)
    @file = file
    @exercise_sets = YAML.load(IO.read(file)).with_indifferent_access()[:exercise_sets]
    self
  end

  def save
    File.open(@file, "w") do |out|
      YAML.dump({:exercise_sets=>@exercise_sets}, out)
    end
  end

  def exercise_info(title)
    exercise = nil
    parent_set = @exercise_sets.detect do |s|
      exercise = s[:exercises].detect {|ex| ex[:title] == title.directorize}
    end
    raise "Can't find set for exercise: #{title}" unless parent_set
    raise "Can't find exercise info for: #{title}" unless exercise

    {:exercise_set_title => parent_set[:title].titleize,
     :exercise_set_description => parent_set[:description],
     :exercise_set_push_id => parent_set[:push_id],
     :title=> exercise[:title].titleize,
     :order => exercise[:order],
     :push_id => exercise[:push_id] }
  end

  def set_exercise_info(title, info_hash = {})
    exercise = nil
    @exercise_sets.detect do |s|
      exercise = s[:exercises].detect {|ex| ex[:title] == title.directorize}
    end
    raise "Can't find exercise: #{title}" unless exercise

    info_hash.each_pair do |k, v|
      exercise[k] = v
    end
 end

  def set_exercise_set_info(set_title, info_hash={})
    set = @exercise_sets.find {|s| s[:title] == set_title.directorize}
    raise "Can't find set: #{set_title}" unless set
    info_hash.each_pair {|k,v| set[k] = v}
  end
end

class String
  def directorize
    self.gsub(/\s+/,"_").downcase
  end
end

if __FILE__ == $0
  start
end

# vim: set filetype=ruby
