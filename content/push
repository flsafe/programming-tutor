#!/usr/bin/ruby

require 'rubygems'
require 'yaml'
require 'active_record'
require 'active_support'
require 'logger'
require 'pp'

# Assumes this script is called from the project root
PROJ_HOME = Dir.getwd
CONTENT_HOME = "#{PROJ_HOME}/content"

# The c header file for the template utils
COZY_TEMPL_UTIL_H = "#{PROJ_HOME}/content/cozy_template_utils.h"

# The cozy template utils that control system resources when running the user soluton
COZY_TEMPL_UTIL_C = "#{PROJ_HOME}/content/cozy_template_utils.c"

# In the exercse text use <filename.c> to subsititue file text
FILE_SUB_REGEX = /\[\[(.+)\]\]/

# Text between [startcode] and [endcode] is wrapped around <pre><code> </code></pre>
# and any < characters in between are escaped to &lt;
CODE_TAG_REGEX = /\[startcode\](.*?)\[endcode\]/m

# Establish DB connection here because some gems require
# a DB before being loaded
#ActiveRecord::Base.logger = Logger.new(STDERR)
db_config = YAML::load(File.open("#{PROJ_HOME}/config/database.yml"))
ActiveRecord::Base.establish_connection(db_config[ ENV['RAILS_ENV']||'development'] )

require 'acts-as-taggable-on'

# Load the exercise model files
require "#{PROJ_HOME}/lib/cozy_string_utils"
require "#{PROJ_HOME}/lib/unit_test_runner"
require "#{PROJ_HOME}/app/models/exercise_set"
require "#{PROJ_HOME}/app/models/hint"
require "#{PROJ_HOME}/app/models/unit_test"
require "#{PROJ_HOME}/app/models/solution_template"
require "#{PROJ_HOME}/app/models/exercise"

Dir.chdir(CONTENT_HOME)

def start
  Dir.foreach(Dir.getwd) do |exercise_title|
    create_or_update_by(exercise_title) if valid_exercise?(exercise_title)
  end
end

def valid_exercise?(exercise_title)
  if File.directory?(exercise_title)
    if exercise_title != "." and exercise_title != ".."
      return true
    end
  end
end

def create_or_update_by(exercise_title_dir)
  pcwd = Dir.getwd
  Dir.chdir(exercise_title_dir)
  exercise_title = exercise_title_dir.titleize
  begin
    exercise = Exercise.find_by_title(exercise_title) || Exercise.new
    exercise.title = exercise_title
    populate_and_save_exercise(exercise)
  rescue Exception
    puts "Oops! #{$!}" 
    puts $!.backtrace
    exit 1
  end
  Dir.chdir(pcwd)
end

def populate_and_save_exercise(exercise)
  populate_primitives(exercise)
  populate_assoc_models(exercise)
  save_with_exercise_set_and_order(exercise)
end

def save_with_exercise_set_and_order(exercise)
   exercise_info = load_exercise_yaml()[exercise.title]
   raise "No exercise info for #{exercise.title} in exercise-sets.yml" unless exercise_info

   exercise.order = exercise_info[:order]

   set = ExerciseSet.find_by_title(exercise_info[:exercise_set_title])
   unless set
    set = ExerciseSet.new
    set.title = exercise_info[:exercise_set_title] 
    set.description = exercise_info[:exercise_set_description] 
    set.save!
    raise "Couldn't save #{exercise.title}\n#{exercise.errors.full_messages()}" unless set.exercises << exercise 
   else
     raise "Couldn't save #{exercise.title}\n#{exercise.errors.full_messages()}" unless set.exercises << exercise
   end
end

def load_exercise_yaml()
  @exercise_sets = YAML.load(IO.read("#{CONTENT_HOME}/exercise-sets.yml")).with_indifferent_access()[:exercise_sets]

  exercise_set_info = {}
  exercise_info = {}

  @exercise_sets.each_pair do |set_title, exercises_array|
    exercises_array.each do |set| 
      if set[:exercise_set_description]
        exercise_set_info = {:exercise_set_title=>set_title.titleize, :exercise_set_description=>set[:exercise_set_description]}
        break
      end
    end
    exercises_array.each do |exercise| 
      exercise[:title] = exercise[:title].titleize if exercise[:title]
      if exercise[:title]
        exercise_info[exercise[:title]] = exercise_set_info.merge(:order=>exercise[:order])
      end
    end
  end
  return exercise_info
end

def populate_primitives(exercise)
    #TODO: Use look at the database fields to figure out
    # what fields to read in.
    exercise.description = read_field('description')
    exercise.problem = read_field('problem')
    exercise.tutorial =  read_field('tutorial')
    exercise.minutes = read_field('minutes').to_i
    exercise.finished = read_field('finished').to_i
    exercise.algorithm_list = read_field('algorithm_list')
    exercise.data_structure_list = read_field('data_structure_list')
end

def populate_assoc_models(exercise)
  # TODO: Currently only supporting one solution template and unit test
  # per exercise. 
  exercise.solution_templates.replace( new_solution_template )
  exercise.unit_tests.replace( new_unit_test )
  exercise.hints.replace( new_hints )
end

def new_solution_template
  template = SolutionTemplate.new
  template.src_language = 'c'
  template.src_code = IO.read('solution_template.c')
  [ template ]
end

def new_unit_test
  unit_test = UnitTest.new
  unit_test.src_language = 'ruby'
  unit_test.src_code = IO.read('unit_test.rb')
  [ unit_test ]
end

def new_hints
  hints = []
  Dir.foreach(Dir.getwd) do | filename | 
    if hint_file?(filename)
     hint = Hint.new
     hint.text = IO.read(filename)
     hints << hint
    end
  end
  hints
end

def hint_file?(filename)
  return true if filename =~ /^hint\d+/
end

def read_field(field)
  perform_subs( IO.read(field).strip.chomp )
end

def perform_subs(text)
  complete_text = sub_file_references(text)
  escaped_text = sub_start_end_code(complete_text)
end

def sub_file_references(text)
  while FILE_SUB_REGEX =~ text
    text = sub_file_reference(text) 
  end
  text
end

def sub_file_reference(text)
  filename = FILE_SUB_REGEX.match(text)[1]
  if filename 
    filetext = CozyStringUtils.escape_back_slashes(IO.read(filename))
    text.sub(FILE_SUB_REGEX, filetext).strip
  else
    text
  end
end

def sub_start_end_code(text)
   text.gsub(CODE_TAG_REGEX) do |match|
      match.gsub!(/(\[startcode\]|\[endcode\])/, '')
      "<pre><code>" + match.gsub(/</, '&lt;').strip + "</code></pre>"
  end
end

if __FILE__ == $0
  start
end

# vim: set filetype=ruby
