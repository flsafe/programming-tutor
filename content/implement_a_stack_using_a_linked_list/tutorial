<h1 id="introduction">Introduction</h1>

<p>
This exercise examines both your knowledge of stacks, linked lists and pointers.
I've tried to explain them in this tutorial but my focus is on implementing
the stack and not the basics of structs and pointers. Check out my list
of tutorials <a href="http://www.blueberrytree.ws/tutorials">here</a> to brush up
on your skills.
</p>

<h1 id="stacks">Stacks</h1>
<p>
Stacks are an interesting data structure. Their behavior can model the concept of
"leaving <i>something</i> to do another thing" and then "returning to the original <i>something</i>".
For example calling a function in a computer program. The function that is called executes
its instructions to completion, then the control returns to the caller. 
This behavior is also useful for traversing trees in 
<a href="http://en.wikipedia.org/wiki/Depth_first_search">Depth-first search</a> order.
</p>

<p>
If you guessed that a stack is analogous to a stack of stuff, like beer containers, then you
are right. They both are a lot of fun. 
</p>

<p>
Stacks are typically defined with three operations: <i>pop</i>, <i>push</i> and <i>peek</i>.
<p>

<p>
Imagine a stack of something, say beer containers, and the stack data structure is
easy enough to understand. Place (push) a stout on the table. Place (push) a lambic on
top of that. Then place (push) a lager on top of that. Now the lager is at
the top of the stack. 
</p>

<p>
Remove the lager (pop) and lambic is at the top. Next
remove the lambic (pop) and the stout is at the top. Pop one more time
and the stack is empty. Take a look at figure 1 one to see
what this would look like.
</p>

<img src="http://images.blueberrytree.ws/push-pop-beer-containers.png"
     alt="Pushing an poping onto the stack"/>
<div class="description">
Figure 1. Pushing onto the stack places
a new thing on top. Popping removes the thing from the top
of the stack</div>

<p>
The peek operation informs us on what element
would be removed were we to do a pop operation. In the example above,
when the lager was at the top of the stack, the peek operation
would have returned the lager but not remove it form the stack.
</p>

<p>
The order of removal is then lager, lambic, stout. Notice that
the order is in first in, last out (FILO). Pop removes and returns
items in the reverse order that they were placed into the stack.
</p>

<h1>Alright, Stacks Are Easy. What About Linked Lists?</h1>
<p>
The problem asks us to implement the stack using a linked list.
A linked list is a structure made up of "nodes". Each node
contains both data and a reference, in our case a pointer, to the
next node. Thus we have a list of nodes that are all linked to each other.
</p>

<p>
There is a special pointer called the head pointer. It points to the
first node of the linked list. This is important because without it
there would be no way to access the linked list in memory. Kind of like
loosing the remote control to the television. As we manipulate the
linked list it is important to maintain the head pointer correctly. 
I have used my amazingly adequate drawing skills to show you
what this looks like in figure 2 below.
</p>

<img src="http://images.blueberrytree.ws/linked-list.png"
     alt="Nodes linked to eachother via via pointers. A special
          head pointer points the first node of the list"/>
<div class="description">
Figure 2. The special head pointer points to the first node. Each
node of the list points to the next node in the list. The last
node points to null.
</div>

<p>
Our <i>push</i> operation is implemented by 
inserting a new node as the first node of the linked list.
The pop operation is implemented by removing the first node.
Now we can imagine that the "top" of our stack is always the first
element of this linked list.
</p>

<p>
Adding the first node of a linked list involves 
allocating a new node, link it to the first node of the list, then
update the head pointer to point to the newly allocated node as seen in
figure 3 below.
</p>

<img src="http://images.blueberrytree.ws/insert-front-linked-list.png"
     alt="Inserting a new node at the front of the linked list"/>
<div class="description">
Figure 3. Each node has data and a "next" pointer that points to the next
node in the list. The newly allocated node's "next" pointer points to the first
node of the list. Then head gets updated.
</div>

<p>
To remove the first node we update head to
point to the second node of the linked list. Then we
deallocate the node node previously pointed to by head.
Figure 4 shows how to do it.
</p>
<img src="http://images.blueberrytree.ws/remove-front-linked-list.png.png"
     alt="Removing the first node of a linked list requires updating 
          head to point to the second element in the list. Be careful
          not to loose your pointer to the first node when updating
          head!"/>
<div class="description">
Figure 4. Removing the first node of a linked list requires updating 
head to point to the second element in the list. Be careful
not to loose your pointer to the first node when updating
head! You need to to deallocate the node. Here I've temporally stored it
in tmp. 
</div>

<p>
Not too bad! However, the devil is in the details! Especially
since we are solving this exercise in C. The pointer manipulation
can be difficult to understand. 
</p>

<p>
Let's take a look at a solution that puts all this together. However
it's not quite right.
</p>

[startcode]
typedef struct stack stack;
struct stack{
  stack *next;
  int  val;
};

int push(stack *s, int val){
  stack* newnode = malloc(sizeof(stack));
  if(! newnode)
    return 0;

  newnode->val = val;
  newnode->next = s;

  s = newnode;

  return 1;
}

int pop(stack *s, int *val){
  stack* top;
  if(! s)
    return 0;

  top = s;
  *val = top->val;
  s = top->next;
  free(top);

  return 1;
}
[endcode]

<p>
So what's wrong with the code above? Lets take a look at
some code that calls on the code above.
</p>

[startcode]
stack* head = NULL;

push(head, 1); /* ? head->val = 1 */

push(head, 2); /* ? head->val = 2 */

push(head, 3); /* ? head->val = 3 */
[endcode]

<p>
We start with a head that points to NULL, also
known as an empty linked list. Then we
push several elements into our stack. As described in the previous figures, 
when we push into the stack the expectation is that the head pointer
will be updated and point to the new node. But that doesn't happen.
</p>

<p>
Remember that <i>head</i> is passed as a function argument by value.
When <i>push</i> or <i>pop</i> are called, they are given not some kind
of reference to <i>head</i> but a copy of head. A copy of a memory address. 
</p>

<p>
Inside push and pop, you can mess with the copy of head all you want but it will never
affect the real head in the code above. This is where the bug is. Head
is never updated.
</p>

<p>
You may have seen code that uses the following idiom:
</p>

[startcode]
struct system_settings settings;

get_default_settings(&settings); 

settings.setting1 == 10; /* true */
settings.pwn      == 1;  /* true */

void get_default_settings(struct system_settings *settings){
  settings->setting1 = 10;
  settings->pwn      = 1;
}
[endcode]

<p>
Our imaginary system settings struct is modified by the function 
<i>get_default_settings</i> because we pass a pointer to the 
struct and not a copy of it. The function
<i>get_default_settings</i> uses the pointer to update the structure
using the <i>-&gt;</i> operator.
We can fix our stack implementation by applying the same concept only
instead of using a pointer to a struct, we will use a pointer
to a pointer. 
</p>

[startcode]
stack *head = NULL;

push(&head, 1); 

push(&head, 2);

push(&head, 3);
[endcode]

<p>
Notice that the arugument is now
<i>&amp;head</i>. Now that our <i>push</i> and <i>pop</i> functions have a pointer
to the head they can update it. This is what we needed all along!
And now we can implement a proper solution.
</p>

[startcode]
[[solution.c]]
[endcode]

<p>
The functions push and pop take a pointer to head as an argument. To access head 
within push and pop we use the <i>*s</i> notation. Remember that the dereference 
operator <i>*</i> is used to reference what the pointer points to. 
Say this three times fast: s is a pointer to the head pointer, *s
is the head pointer; a pointer to the head node.  
</p>

<p>
Some code snippets to illustrate.
</p>

[startcode]
stack *head = *s;

/* or */

stack *top_of_stack = *s;

/* or */

stack *first_node = *s;
[endcode]

<p>
To access the struct values of the head node we use the following code.
</p>

[startcode]
int val = (*s)->val;
stack *second_node = (*s)->next;
[endcode]

<p>
This notation is a bit funky. The parenthesis around the <i>*s</i>
are required because the <i>-&gt;</i> precedence is higher than the
<i>*</i> operator. 
</p>
